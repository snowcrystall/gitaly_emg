// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package gitalypb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OperationServiceClient is the client API for OperationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OperationServiceClient interface {
	UserCreateBranch(ctx context.Context, in *UserCreateBranchRequest, opts ...grpc.CallOption) (*UserCreateBranchResponse, error)
	UserUpdateBranch(ctx context.Context, in *UserUpdateBranchRequest, opts ...grpc.CallOption) (*UserUpdateBranchResponse, error)
	UserDeleteBranch(ctx context.Context, in *UserDeleteBranchRequest, opts ...grpc.CallOption) (*UserDeleteBranchResponse, error)
	// UserCreateTag creates a new tag.
	UserCreateTag(ctx context.Context, in *UserCreateTagRequest, opts ...grpc.CallOption) (*UserCreateTagResponse, error)
	UserDeleteTag(ctx context.Context, in *UserDeleteTagRequest, opts ...grpc.CallOption) (*UserDeleteTagResponse, error)
	// UserMergeRef creates a merge commit and updates target_ref to point to that
	// new commit. The first parent of the merge commit (the main line) is taken
	// from first_parent_ref. The second parent is specified by its commit ID in source_sha.
	// If target_ref already exists it will be overwritten.
	UserMergeToRef(ctx context.Context, in *UserMergeToRefRequest, opts ...grpc.CallOption) (*UserMergeToRefResponse, error)
	// UserMergeBranch tries to merge the given commit into the target branch.
	// The merge commit is created with the given user as author/committer and
	// the given message.
	//
	// This RPC requires confirmation to make any user-visible changes to the
	// repository. The first request sent shall contain details about the
	// requested merge, which will result in a response with the created merge
	// commit ID. Only if a second message with `apply = true` is sent will the
	// merge be applied.
	UserMergeBranch(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserMergeBranchClient, error)
	// UserFFBranch tries to perform a fast-forward merge of the given branch to
	// the given commit. If the merge is not a fast-forward merge, the request
	// will fail. The RPC will return an empty response in case updating the
	// reference fails e.g. because of a race.
	UserFFBranch(ctx context.Context, in *UserFFBranchRequest, opts ...grpc.CallOption) (*UserFFBranchResponse, error)
	// UserCherryPick tries to perform a cherry-pick of a given commit onto a
	// branch.
	UserCherryPick(ctx context.Context, in *UserCherryPickRequest, opts ...grpc.CallOption) (*UserCherryPickResponse, error)
	// UserCommitFiles builds a commit from a stream of actions and updates the target branch to point to it.
	// UserCommitFilesRequest with a UserCommitFilesRequestHeader must be sent as the first message of the stream.
	// Following that, a variable number of actions can be sent to build a new commit. Each action consists of
	// a header followed by content if used by the action.
	UserCommitFiles(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserCommitFilesClient, error)
	// UserRebaseConfirmable rebases the given remote branch onto a target
	// branch. The remote branch may be part of another repository.
	//
	// This RPC requires confirmation to make any user-visible changes to the
	// repository. The first request sent shall contains details about the
	// requested rebase, which will result in a response with the created rebase
	// commit ID. Only if a second message with `apply = true` is sent will the
	// rebase be applied.
	UserRebaseConfirmable(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserRebaseConfirmableClient, error)
	// UserRevert tries to perform a revert of a given commit onto a branch.
	UserRevert(ctx context.Context, in *UserRevertRequest, opts ...grpc.CallOption) (*UserRevertResponse, error)
	// UserSquash squashes a range of commits into a single commit.
	UserSquash(ctx context.Context, in *UserSquashRequest, opts ...grpc.CallOption) (*UserSquashResponse, error)
	// UserApplyPatch applies patches to a given branch.
	UserApplyPatch(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserApplyPatchClient, error)
	// UserUpdateSubmodule updates a submodule to point to a new commit.
	UserUpdateSubmodule(ctx context.Context, in *UserUpdateSubmoduleRequest, opts ...grpc.CallOption) (*UserUpdateSubmoduleResponse, error)
}

type operationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOperationServiceClient(cc grpc.ClientConnInterface) OperationServiceClient {
	return &operationServiceClient{cc}
}

func (c *operationServiceClient) UserCreateBranch(ctx context.Context, in *UserCreateBranchRequest, opts ...grpc.CallOption) (*UserCreateBranchResponse, error) {
	out := new(UserCreateBranchResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserCreateBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserUpdateBranch(ctx context.Context, in *UserUpdateBranchRequest, opts ...grpc.CallOption) (*UserUpdateBranchResponse, error) {
	out := new(UserUpdateBranchResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserUpdateBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserDeleteBranch(ctx context.Context, in *UserDeleteBranchRequest, opts ...grpc.CallOption) (*UserDeleteBranchResponse, error) {
	out := new(UserDeleteBranchResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserDeleteBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserCreateTag(ctx context.Context, in *UserCreateTagRequest, opts ...grpc.CallOption) (*UserCreateTagResponse, error) {
	out := new(UserCreateTagResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserCreateTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserDeleteTag(ctx context.Context, in *UserDeleteTagRequest, opts ...grpc.CallOption) (*UserDeleteTagResponse, error) {
	out := new(UserDeleteTagResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserDeleteTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserMergeToRef(ctx context.Context, in *UserMergeToRefRequest, opts ...grpc.CallOption) (*UserMergeToRefResponse, error) {
	out := new(UserMergeToRefResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserMergeToRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserMergeBranch(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserMergeBranchClient, error) {
	stream, err := c.cc.NewStream(ctx, &OperationService_ServiceDesc.Streams[0], "/gitaly.OperationService/UserMergeBranch", opts...)
	if err != nil {
		return nil, err
	}
	x := &operationServiceUserMergeBranchClient{stream}
	return x, nil
}

type OperationService_UserMergeBranchClient interface {
	Send(*UserMergeBranchRequest) error
	Recv() (*UserMergeBranchResponse, error)
	grpc.ClientStream
}

type operationServiceUserMergeBranchClient struct {
	grpc.ClientStream
}

func (x *operationServiceUserMergeBranchClient) Send(m *UserMergeBranchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *operationServiceUserMergeBranchClient) Recv() (*UserMergeBranchResponse, error) {
	m := new(UserMergeBranchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operationServiceClient) UserFFBranch(ctx context.Context, in *UserFFBranchRequest, opts ...grpc.CallOption) (*UserFFBranchResponse, error) {
	out := new(UserFFBranchResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserFFBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserCherryPick(ctx context.Context, in *UserCherryPickRequest, opts ...grpc.CallOption) (*UserCherryPickResponse, error) {
	out := new(UserCherryPickResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserCherryPick", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserCommitFiles(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserCommitFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &OperationService_ServiceDesc.Streams[1], "/gitaly.OperationService/UserCommitFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &operationServiceUserCommitFilesClient{stream}
	return x, nil
}

type OperationService_UserCommitFilesClient interface {
	Send(*UserCommitFilesRequest) error
	CloseAndRecv() (*UserCommitFilesResponse, error)
	grpc.ClientStream
}

type operationServiceUserCommitFilesClient struct {
	grpc.ClientStream
}

func (x *operationServiceUserCommitFilesClient) Send(m *UserCommitFilesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *operationServiceUserCommitFilesClient) CloseAndRecv() (*UserCommitFilesResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UserCommitFilesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operationServiceClient) UserRebaseConfirmable(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserRebaseConfirmableClient, error) {
	stream, err := c.cc.NewStream(ctx, &OperationService_ServiceDesc.Streams[2], "/gitaly.OperationService/UserRebaseConfirmable", opts...)
	if err != nil {
		return nil, err
	}
	x := &operationServiceUserRebaseConfirmableClient{stream}
	return x, nil
}

type OperationService_UserRebaseConfirmableClient interface {
	Send(*UserRebaseConfirmableRequest) error
	Recv() (*UserRebaseConfirmableResponse, error)
	grpc.ClientStream
}

type operationServiceUserRebaseConfirmableClient struct {
	grpc.ClientStream
}

func (x *operationServiceUserRebaseConfirmableClient) Send(m *UserRebaseConfirmableRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *operationServiceUserRebaseConfirmableClient) Recv() (*UserRebaseConfirmableResponse, error) {
	m := new(UserRebaseConfirmableResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operationServiceClient) UserRevert(ctx context.Context, in *UserRevertRequest, opts ...grpc.CallOption) (*UserRevertResponse, error) {
	out := new(UserRevertResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserRevert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserSquash(ctx context.Context, in *UserSquashRequest, opts ...grpc.CallOption) (*UserSquashResponse, error) {
	out := new(UserSquashResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserSquash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserApplyPatch(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserApplyPatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &OperationService_ServiceDesc.Streams[3], "/gitaly.OperationService/UserApplyPatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &operationServiceUserApplyPatchClient{stream}
	return x, nil
}

type OperationService_UserApplyPatchClient interface {
	Send(*UserApplyPatchRequest) error
	CloseAndRecv() (*UserApplyPatchResponse, error)
	grpc.ClientStream
}

type operationServiceUserApplyPatchClient struct {
	grpc.ClientStream
}

func (x *operationServiceUserApplyPatchClient) Send(m *UserApplyPatchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *operationServiceUserApplyPatchClient) CloseAndRecv() (*UserApplyPatchResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UserApplyPatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operationServiceClient) UserUpdateSubmodule(ctx context.Context, in *UserUpdateSubmoduleRequest, opts ...grpc.CallOption) (*UserUpdateSubmoduleResponse, error) {
	out := new(UserUpdateSubmoduleResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserUpdateSubmodule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OperationServiceServer is the server API for OperationService service.
// All implementations must embed UnimplementedOperationServiceServer
// for forward compatibility
type OperationServiceServer interface {
	UserCreateBranch(context.Context, *UserCreateBranchRequest) (*UserCreateBranchResponse, error)
	UserUpdateBranch(context.Context, *UserUpdateBranchRequest) (*UserUpdateBranchResponse, error)
	UserDeleteBranch(context.Context, *UserDeleteBranchRequest) (*UserDeleteBranchResponse, error)
	// UserCreateTag creates a new tag.
	UserCreateTag(context.Context, *UserCreateTagRequest) (*UserCreateTagResponse, error)
	UserDeleteTag(context.Context, *UserDeleteTagRequest) (*UserDeleteTagResponse, error)
	// UserMergeRef creates a merge commit and updates target_ref to point to that
	// new commit. The first parent of the merge commit (the main line) is taken
	// from first_parent_ref. The second parent is specified by its commit ID in source_sha.
	// If target_ref already exists it will be overwritten.
	UserMergeToRef(context.Context, *UserMergeToRefRequest) (*UserMergeToRefResponse, error)
	// UserMergeBranch tries to merge the given commit into the target branch.
	// The merge commit is created with the given user as author/committer and
	// the given message.
	//
	// This RPC requires confirmation to make any user-visible changes to the
	// repository. The first request sent shall contain details about the
	// requested merge, which will result in a response with the created merge
	// commit ID. Only if a second message with `apply = true` is sent will the
	// merge be applied.
	UserMergeBranch(OperationService_UserMergeBranchServer) error
	// UserFFBranch tries to perform a fast-forward merge of the given branch to
	// the given commit. If the merge is not a fast-forward merge, the request
	// will fail. The RPC will return an empty response in case updating the
	// reference fails e.g. because of a race.
	UserFFBranch(context.Context, *UserFFBranchRequest) (*UserFFBranchResponse, error)
	// UserCherryPick tries to perform a cherry-pick of a given commit onto a
	// branch.
	UserCherryPick(context.Context, *UserCherryPickRequest) (*UserCherryPickResponse, error)
	// UserCommitFiles builds a commit from a stream of actions and updates the target branch to point to it.
	// UserCommitFilesRequest with a UserCommitFilesRequestHeader must be sent as the first message of the stream.
	// Following that, a variable number of actions can be sent to build a new commit. Each action consists of
	// a header followed by content if used by the action.
	UserCommitFiles(OperationService_UserCommitFilesServer) error
	// UserRebaseConfirmable rebases the given remote branch onto a target
	// branch. The remote branch may be part of another repository.
	//
	// This RPC requires confirmation to make any user-visible changes to the
	// repository. The first request sent shall contains details about the
	// requested rebase, which will result in a response with the created rebase
	// commit ID. Only if a second message with `apply = true` is sent will the
	// rebase be applied.
	UserRebaseConfirmable(OperationService_UserRebaseConfirmableServer) error
	// UserRevert tries to perform a revert of a given commit onto a branch.
	UserRevert(context.Context, *UserRevertRequest) (*UserRevertResponse, error)
	// UserSquash squashes a range of commits into a single commit.
	UserSquash(context.Context, *UserSquashRequest) (*UserSquashResponse, error)
	// UserApplyPatch applies patches to a given branch.
	UserApplyPatch(OperationService_UserApplyPatchServer) error
	// UserUpdateSubmodule updates a submodule to point to a new commit.
	UserUpdateSubmodule(context.Context, *UserUpdateSubmoduleRequest) (*UserUpdateSubmoduleResponse, error)
	mustEmbedUnimplementedOperationServiceServer()
}

// UnimplementedOperationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOperationServiceServer struct {
}

func (UnimplementedOperationServiceServer) UserCreateBranch(context.Context, *UserCreateBranchRequest) (*UserCreateBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreateBranch not implemented")
}
func (UnimplementedOperationServiceServer) UserUpdateBranch(context.Context, *UserUpdateBranchRequest) (*UserUpdateBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdateBranch not implemented")
}
func (UnimplementedOperationServiceServer) UserDeleteBranch(context.Context, *UserDeleteBranchRequest) (*UserDeleteBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDeleteBranch not implemented")
}
func (UnimplementedOperationServiceServer) UserCreateTag(context.Context, *UserCreateTagRequest) (*UserCreateTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreateTag not implemented")
}
func (UnimplementedOperationServiceServer) UserDeleteTag(context.Context, *UserDeleteTagRequest) (*UserDeleteTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDeleteTag not implemented")
}
func (UnimplementedOperationServiceServer) UserMergeToRef(context.Context, *UserMergeToRefRequest) (*UserMergeToRefResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserMergeToRef not implemented")
}
func (UnimplementedOperationServiceServer) UserMergeBranch(OperationService_UserMergeBranchServer) error {
	return status.Errorf(codes.Unimplemented, "method UserMergeBranch not implemented")
}
func (UnimplementedOperationServiceServer) UserFFBranch(context.Context, *UserFFBranchRequest) (*UserFFBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserFFBranch not implemented")
}
func (UnimplementedOperationServiceServer) UserCherryPick(context.Context, *UserCherryPickRequest) (*UserCherryPickResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCherryPick not implemented")
}
func (UnimplementedOperationServiceServer) UserCommitFiles(OperationService_UserCommitFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method UserCommitFiles not implemented")
}
func (UnimplementedOperationServiceServer) UserRebaseConfirmable(OperationService_UserRebaseConfirmableServer) error {
	return status.Errorf(codes.Unimplemented, "method UserRebaseConfirmable not implemented")
}
func (UnimplementedOperationServiceServer) UserRevert(context.Context, *UserRevertRequest) (*UserRevertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRevert not implemented")
}
func (UnimplementedOperationServiceServer) UserSquash(context.Context, *UserSquashRequest) (*UserSquashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserSquash not implemented")
}
func (UnimplementedOperationServiceServer) UserApplyPatch(OperationService_UserApplyPatchServer) error {
	return status.Errorf(codes.Unimplemented, "method UserApplyPatch not implemented")
}
func (UnimplementedOperationServiceServer) UserUpdateSubmodule(context.Context, *UserUpdateSubmoduleRequest) (*UserUpdateSubmoduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdateSubmodule not implemented")
}
func (UnimplementedOperationServiceServer) mustEmbedUnimplementedOperationServiceServer() {}

// UnsafeOperationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OperationServiceServer will
// result in compilation errors.
type UnsafeOperationServiceServer interface {
	mustEmbedUnimplementedOperationServiceServer()
}

func RegisterOperationServiceServer(s grpc.ServiceRegistrar, srv OperationServiceServer) {
	s.RegisterService(&OperationService_ServiceDesc, srv)
}

func _OperationService_UserCreateBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCreateBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserCreateBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserCreateBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserCreateBranch(ctx, req.(*UserCreateBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserUpdateBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserUpdateBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserUpdateBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserUpdateBranch(ctx, req.(*UserUpdateBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserDeleteBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDeleteBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserDeleteBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserDeleteBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserDeleteBranch(ctx, req.(*UserDeleteBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserCreateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCreateTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserCreateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserCreateTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserCreateTag(ctx, req.(*UserCreateTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserDeleteTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDeleteTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserDeleteTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserDeleteTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserDeleteTag(ctx, req.(*UserDeleteTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserMergeToRef_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMergeToRefRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserMergeToRef(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserMergeToRef",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserMergeToRef(ctx, req.(*UserMergeToRefRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserMergeBranch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OperationServiceServer).UserMergeBranch(&operationServiceUserMergeBranchServer{stream})
}

type OperationService_UserMergeBranchServer interface {
	Send(*UserMergeBranchResponse) error
	Recv() (*UserMergeBranchRequest, error)
	grpc.ServerStream
}

type operationServiceUserMergeBranchServer struct {
	grpc.ServerStream
}

func (x *operationServiceUserMergeBranchServer) Send(m *UserMergeBranchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *operationServiceUserMergeBranchServer) Recv() (*UserMergeBranchRequest, error) {
	m := new(UserMergeBranchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OperationService_UserFFBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserFFBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserFFBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserFFBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserFFBranch(ctx, req.(*UserFFBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserCherryPick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCherryPickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserCherryPick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserCherryPick",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserCherryPick(ctx, req.(*UserCherryPickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserCommitFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OperationServiceServer).UserCommitFiles(&operationServiceUserCommitFilesServer{stream})
}

type OperationService_UserCommitFilesServer interface {
	SendAndClose(*UserCommitFilesResponse) error
	Recv() (*UserCommitFilesRequest, error)
	grpc.ServerStream
}

type operationServiceUserCommitFilesServer struct {
	grpc.ServerStream
}

func (x *operationServiceUserCommitFilesServer) SendAndClose(m *UserCommitFilesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *operationServiceUserCommitFilesServer) Recv() (*UserCommitFilesRequest, error) {
	m := new(UserCommitFilesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OperationService_UserRebaseConfirmable_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OperationServiceServer).UserRebaseConfirmable(&operationServiceUserRebaseConfirmableServer{stream})
}

type OperationService_UserRebaseConfirmableServer interface {
	Send(*UserRebaseConfirmableResponse) error
	Recv() (*UserRebaseConfirmableRequest, error)
	grpc.ServerStream
}

type operationServiceUserRebaseConfirmableServer struct {
	grpc.ServerStream
}

func (x *operationServiceUserRebaseConfirmableServer) Send(m *UserRebaseConfirmableResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *operationServiceUserRebaseConfirmableServer) Recv() (*UserRebaseConfirmableRequest, error) {
	m := new(UserRebaseConfirmableRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OperationService_UserRevert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRevertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserRevert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserRevert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserRevert(ctx, req.(*UserRevertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserSquash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSquashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserSquash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserSquash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserSquash(ctx, req.(*UserSquashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserApplyPatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OperationServiceServer).UserApplyPatch(&operationServiceUserApplyPatchServer{stream})
}

type OperationService_UserApplyPatchServer interface {
	SendAndClose(*UserApplyPatchResponse) error
	Recv() (*UserApplyPatchRequest, error)
	grpc.ServerStream
}

type operationServiceUserApplyPatchServer struct {
	grpc.ServerStream
}

func (x *operationServiceUserApplyPatchServer) SendAndClose(m *UserApplyPatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *operationServiceUserApplyPatchServer) Recv() (*UserApplyPatchRequest, error) {
	m := new(UserApplyPatchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OperationService_UserUpdateSubmodule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateSubmoduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserUpdateSubmodule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserUpdateSubmodule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserUpdateSubmodule(ctx, req.(*UserUpdateSubmoduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OperationService_ServiceDesc is the grpc.ServiceDesc for OperationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OperationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gitaly.OperationService",
	HandlerType: (*OperationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserCreateBranch",
			Handler:    _OperationService_UserCreateBranch_Handler,
		},
		{
			MethodName: "UserUpdateBranch",
			Handler:    _OperationService_UserUpdateBranch_Handler,
		},
		{
			MethodName: "UserDeleteBranch",
			Handler:    _OperationService_UserDeleteBranch_Handler,
		},
		{
			MethodName: "UserCreateTag",
			Handler:    _OperationService_UserCreateTag_Handler,
		},
		{
			MethodName: "UserDeleteTag",
			Handler:    _OperationService_UserDeleteTag_Handler,
		},
		{
			MethodName: "UserMergeToRef",
			Handler:    _OperationService_UserMergeToRef_Handler,
		},
		{
			MethodName: "UserFFBranch",
			Handler:    _OperationService_UserFFBranch_Handler,
		},
		{
			MethodName: "UserCherryPick",
			Handler:    _OperationService_UserCherryPick_Handler,
		},
		{
			MethodName: "UserRevert",
			Handler:    _OperationService_UserRevert_Handler,
		},
		{
			MethodName: "UserSquash",
			Handler:    _OperationService_UserSquash_Handler,
		},
		{
			MethodName: "UserUpdateSubmodule",
			Handler:    _OperationService_UserUpdateSubmodule_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UserMergeBranch",
			Handler:       _OperationService_UserMergeBranch_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UserCommitFiles",
			Handler:       _OperationService_UserCommitFiles_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UserRebaseConfirmable",
			Handler:       _OperationService_UserRebaseConfirmable_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UserApplyPatch",
			Handler:       _OperationService_UserApplyPatch_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "operations.proto",
}
