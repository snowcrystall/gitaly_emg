// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package gitalypb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ConflictsServiceClient is the client API for ConflictsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConflictsServiceClient interface {
	ListConflictFiles(ctx context.Context, in *ListConflictFilesRequest, opts ...grpc.CallOption) (ConflictsService_ListConflictFilesClient, error)
	// ResolveConflicts tries to resolve a conflicting merge with a set of
	// user-provided merge resolutions. If resolving the conflict succeeds, the
	// result will be a new merge commit.
	ResolveConflicts(ctx context.Context, opts ...grpc.CallOption) (ConflictsService_ResolveConflictsClient, error)
}

type conflictsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConflictsServiceClient(cc grpc.ClientConnInterface) ConflictsServiceClient {
	return &conflictsServiceClient{cc}
}

func (c *conflictsServiceClient) ListConflictFiles(ctx context.Context, in *ListConflictFilesRequest, opts ...grpc.CallOption) (ConflictsService_ListConflictFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &ConflictsService_ServiceDesc.Streams[0], "/gitaly.ConflictsService/ListConflictFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &conflictsServiceListConflictFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ConflictsService_ListConflictFilesClient interface {
	Recv() (*ListConflictFilesResponse, error)
	grpc.ClientStream
}

type conflictsServiceListConflictFilesClient struct {
	grpc.ClientStream
}

func (x *conflictsServiceListConflictFilesClient) Recv() (*ListConflictFilesResponse, error) {
	m := new(ListConflictFilesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *conflictsServiceClient) ResolveConflicts(ctx context.Context, opts ...grpc.CallOption) (ConflictsService_ResolveConflictsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ConflictsService_ServiceDesc.Streams[1], "/gitaly.ConflictsService/ResolveConflicts", opts...)
	if err != nil {
		return nil, err
	}
	x := &conflictsServiceResolveConflictsClient{stream}
	return x, nil
}

type ConflictsService_ResolveConflictsClient interface {
	Send(*ResolveConflictsRequest) error
	CloseAndRecv() (*ResolveConflictsResponse, error)
	grpc.ClientStream
}

type conflictsServiceResolveConflictsClient struct {
	grpc.ClientStream
}

func (x *conflictsServiceResolveConflictsClient) Send(m *ResolveConflictsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *conflictsServiceResolveConflictsClient) CloseAndRecv() (*ResolveConflictsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ResolveConflictsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConflictsServiceServer is the server API for ConflictsService service.
// All implementations must embed UnimplementedConflictsServiceServer
// for forward compatibility
type ConflictsServiceServer interface {
	ListConflictFiles(*ListConflictFilesRequest, ConflictsService_ListConflictFilesServer) error
	// ResolveConflicts tries to resolve a conflicting merge with a set of
	// user-provided merge resolutions. If resolving the conflict succeeds, the
	// result will be a new merge commit.
	ResolveConflicts(ConflictsService_ResolveConflictsServer) error
	mustEmbedUnimplementedConflictsServiceServer()
}

// UnimplementedConflictsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedConflictsServiceServer struct {
}

func (UnimplementedConflictsServiceServer) ListConflictFiles(*ListConflictFilesRequest, ConflictsService_ListConflictFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListConflictFiles not implemented")
}
func (UnimplementedConflictsServiceServer) ResolveConflicts(ConflictsService_ResolveConflictsServer) error {
	return status.Errorf(codes.Unimplemented, "method ResolveConflicts not implemented")
}
func (UnimplementedConflictsServiceServer) mustEmbedUnimplementedConflictsServiceServer() {}

// UnsafeConflictsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConflictsServiceServer will
// result in compilation errors.
type UnsafeConflictsServiceServer interface {
	mustEmbedUnimplementedConflictsServiceServer()
}

func RegisterConflictsServiceServer(s grpc.ServiceRegistrar, srv ConflictsServiceServer) {
	s.RegisterService(&ConflictsService_ServiceDesc, srv)
}

func _ConflictsService_ListConflictFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListConflictFilesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConflictsServiceServer).ListConflictFiles(m, &conflictsServiceListConflictFilesServer{stream})
}

type ConflictsService_ListConflictFilesServer interface {
	Send(*ListConflictFilesResponse) error
	grpc.ServerStream
}

type conflictsServiceListConflictFilesServer struct {
	grpc.ServerStream
}

func (x *conflictsServiceListConflictFilesServer) Send(m *ListConflictFilesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ConflictsService_ResolveConflicts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConflictsServiceServer).ResolveConflicts(&conflictsServiceResolveConflictsServer{stream})
}

type ConflictsService_ResolveConflictsServer interface {
	SendAndClose(*ResolveConflictsResponse) error
	Recv() (*ResolveConflictsRequest, error)
	grpc.ServerStream
}

type conflictsServiceResolveConflictsServer struct {
	grpc.ServerStream
}

func (x *conflictsServiceResolveConflictsServer) SendAndClose(m *ResolveConflictsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *conflictsServiceResolveConflictsServer) Recv() (*ResolveConflictsRequest, error) {
	m := new(ResolveConflictsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConflictsService_ServiceDesc is the grpc.ServiceDesc for ConflictsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConflictsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gitaly.ConflictsService",
	HandlerType: (*ConflictsServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListConflictFiles",
			Handler:       _ConflictsService_ListConflictFiles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ResolveConflicts",
			Handler:       _ConflictsService_ResolveConflicts_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "conflicts.proto",
}
